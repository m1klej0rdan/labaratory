/*
1)тип_данных имя_массива[размер];
все элементы массива размещаются в смежных ячейках памяти последовательно друг за другом, образуя непрерывный блок.
отдельная переменная хранит только одно значение,
массив может хранить множество значений одного типа под одним именем

2)при передаче массива в функцию (по значению), массив не копируется целиком.
место этого происходит автоматическое, неявное преобразование: компилятор преобразует массив в указатель на его первый элемент.

Внутри функции arr больше не является массивом. Это локальная переменная типа (int*), которая хранит адрес начала исходного массива.
Оператор sizeof возвращает размер типа данных своей переменной. Внутри функции sizeof(arr) вычисляет размер переменной-указателя
а не размер всего массива, который был передан

Поскольку функция теряет информацию об исходном размере массива из-за decay, размер массива необходимо передавать явно как отдельный аргумент.

3)Объявление двумерного массива требует указания типа данных 
и размеров для каждого измерения (количества строк и количества столбцов) с использованием квадратных скобок.

тип_данных имя_массива[количество_строк][количество_столбцов];

массив хранится как непрерывный блок памяти, где сначала идут все элементы первой строки, затем все элементы второй строки и тд
Доступ к элементам осуществляется с помощью оператора индексирования [] для каждого измерения. Индексы, как и в одномерных массивах, начинаются с нуля.

4)Программа аварийно завершится
Программа продолжит работать, но выдаст неверные данные
Обращение за границы массива называется Undefined Behavior
потому что все зависит от конкретной архитектуры компьютера, операционной системы, настроек компилятора и текущего состояния памяти

Использование циклов с правильными условиями
 Всегда передавать размер массива в функцию


 5)Его принцип работы заключается в последовательном нахождении минимального (или максимального) элемента
 в оставшейся несортированной части массива и перемещении его в начало этой части.(selection sort)

 Эта функция используется в алгоритме сортировки выбором для перемещения найденного минимального элемента на его правильную позицию.


 6)int arr[5]                                      std::array<int, 5>
 Нельзя скопировать напрямую                       Можно копировать и присваивать как любой другой объект
 При передаче распадается до указателя,            Передается по значению (копируется) или по ссылке, сохраняя информацию о размере.
 теряя информацию о размере.                       Имеет методы: .size(), .empty(), .front(), .back(), .fill().
 Нет встроенных методов или функций-членов         
 (например, .size()).


 был введен чтобы объединить производительность и компактность массивов
 с безопасностью и функциональностью STL-контейнеров, таких как std::vector.


 7)Цикл range-based for автоматически итерируется по всем элементам массива (или контейнера) от начала до конца.
for (тип_элемента переменная_итерации : диапазон_данных)

Range-based for автоматически управляет границами, итерируясь ровно по всем существующим элементам, что исключает эту ошибку.
не нужно объявлять переменную-индекс, вычислять размер массива и автоматически определяет тип элементов 


Если необходимо не просто прочитать элементы, а изменить их значения внутри цикла потому что 
Без ссылки будет меняться копия элемента а не оригинал 


8)Для открытия файла нужно создать объект соответствующего класса и передать ему путь к файлу в качестве аргумента конструктора.


оператор извлечения используется для чтения отдельных элементов (чисел, слов) из файла.
Если нужно прочитать файл строка за строкой, включая пробелы внутри строк, используется функция std::getline().

9)Основное отличие заключается в том, когда определяется размер массива и где выделяется память.
Должен быть известен во время компиляции.   Может быть вычислен во время выполнения программы
    Выделяется в стеке                         Выделяется в куче

 Динамические массивы необходимы в ситуациях, когда нельзя заранее знать, сколько элементов понадобится.
 Управление памятью в куче требует ручной очистки, чтобы избежать утечек памяти

 delete используется для освобождения памяти, выделенной под одиночный
 delete[] используется для освобождения памяти, выделенной под массив объектов


 10)динамический массив, способный автоматически изменять свой размер по мере добавления или удаления элементов.
 Он управляет памятью в куче сам, предоставляя безопасный, гибкий и удобный интерфейс.

 []	Доступ к элементу по индексу
 .at()	Доступ к элементу по индексу с проверкой границ
 .front()	Доступ к первому элементу.
 .back()	Доступ к последнему элементу
 .clear()	Удаляет все элементы из вектора
 .empty()	Проверяет, пуст ли вектор (возвращает true или false).


 тем что он решает проблемы ручного управления памятью
 

 11)алиас используются для присвоения существующему типу нового, дополнительного имени
 Синтаксис using позволяет определить алиас более чисто и читабельно

 using UserID = unsigned int;
UserID id1 = 1001;
UserID id2 = 1002;


UserID сразу дает понять, какую именно информацию хранит переменная. Это делает код более понятным без дополнительных комментариев
Если изменяешь базовый тип данных в проекте, то не придется искать и менять его во всем коде можно изменить определение алиаса в одном месте и все


12)Проверить статус: Использовать is_open() или просто объект потока как булево значение.
Сообщить об ошибке: Вывести сообщение об ошибке пользователю или в лог (с использованием std::cerr).
Прекратить выполнение: В зависимости от логики программы, следует либо завершить функцию/программу, либо предпринять альтернативные действия.


спользовать сам поток в качестве условия цикла. Поток автоматически проверяет свое состояние после каждой попытки чтения.
Если чтение прошло успешно, условие while истинно, и цикл продолжается. Если чтение не удалось, цикл прерывается.
.fail(): Устанавливается, если произошла логическая ошибка (например, чтение текста в int). Также устанавливается при фатальных ошибках ввода-вывода.
.bad(): Устанавливается при серьезной фатальной ошибке ввода-вывода (повреждение устройства хранения данных, сбой потока).






*/

#include "string-utils.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <clocale>

using namespace StringUtils;

int main() {

    setlocale(LC_ALL, "ru_RU.UTF-8");
    
    std::vector<std::string> lines; // Вектор для хранения строк из файла
    std::vector<int> wordCounts;    // Вектор для количества слов в каждой строке
    
    
    std::string inputFile = "input.txt";
    std::string outputFile = "output.txt";
    
    // Функция 1: Читаем строки из файла
    std::cout << "Чтение файла " << inputFile << "..." << std::endl;
    int linesRead = readStringsFromFile(inputFile, lines);
    
    if (linesRead == 0) {
        std::cerr << "Ошибка: не удалось прочитать строки из файла" << std::endl;
        return 1; 
    }
    
    std::cout << "Прочитано " << linesRead << " строк" << std::endl;
    
    // Функция 2: Подсчитываем количество слов в каждой строке
    countWordsInLines(lines, wordCounts);
    
    std::cout << "Количество слов в каждой строке:" << std::endl;
    for (int count : wordCounts) {
        std::cout << count << " ";
    }
    std::cout << std::endl;
    
    // Функция 3: Находим самую длинную строку
    int longestIndex = findLongestString(lines);
    
    if (longestIndex != -1) {
        std::cout << "Самая длинная строка: " << lines[longestIndex] << std::endl;
    }
    
    // Функция 4: Сортируем строки по длине
    sortStringsByLength(lines);
    
    std::cout << "Строки отсортированы по длине" << std::endl;
    
    // Записываем результаты в выходной файл
    std::ofstream outFile(outputFile);
    
    // Проверяем, открылся ли выходной файл
    if (!outFile.is_open()) {
        std::cerr << "Ошибка: не удалось открыть файл " << outputFile << " для записи" << std::endl;
        return 1;
    }
    
    // Записываем количество слов в каждой строке
    outFile << "Количество слов в строках: ";
    for (int count : wordCounts) {
        outFile << count << " ";
    }
    outFile << std::endl;
    
    // Записываем самую длинную строку
    if (longestIndex != -1) {
        outFile << "Самая длинная строка: " << lines[longestIndex] << std::endl;
    }
    
    // Записываем отсортированные строки
    outFile << "Отсортированные строки по длине:" << std::endl;
    for (const auto& line : lines) {
        outFile << line << std::endl;
    }
    
    outFile.close(); 
    
    std::cout << "Результаты записаны в файл " << outputFile << std::endl;
    
    return 0; 
}
